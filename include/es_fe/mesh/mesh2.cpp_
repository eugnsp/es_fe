#include <es/fe/mesh.hpp>
#include <es/geom/geometry.hpp>
#include <es_util/function.hpp>
#include <set>
#include <fstream>
#include <string>
#include <algorithm>
#include <limits>
#include <ostream>

namespace fe
{

//////////////////////////////////////////////////////////////////////////
/** Low level index-based element access */


geom::Rect Mesh2::bounding_box() const
{
	double x_min = std::numeric_limits<double>::max();
	double x_max = std::numeric_limits<double>::min();

	double y_min = std::numeric_limits<double>::max();
	double y_max = std::numeric_limits<double>::min();

	// TODO
	//for (auto vertex = begin_bnd_vertex(); vertex != end_bnd_vertex(); ++vertex)
	for (auto vertex = begin_vertex(); vertex != end_vertex(); ++vertex)
	{
		auto& v = vertex->vertex();
		x_min = std::min(x_min, v.x());
		x_max = std::max(x_max, v.x());
		y_min = std::min(y_min, v.y());
		y_max = std::max(y_max, v.y());
	}

	return {{x_min, y_min}, {x_max, y_max}};
}

//////////////////////////////////////////////////////////////////////////
/** Iterators */


auto Mesh2::begin_bnd_vertex() const -> BoundaryVertexIter
{
	return BoundaryVertexIter{*this, first_boundary_halfedge()};
}

auto Mesh2::end_bnd_vertex() const -> BoundaryVertexIter
{
	return BoundaryVertexIter{*this};
}

// auto Mesh2::begin_bnd_edge() const -> Bnd_edge_iter
// {
// 	return Bnd_edge_iter{*this, *first_boundary_halfedge()};
// }

auto Mesh2::end_bnd_edge() const -> Bnd_edge_end_iter
{
	return {};
}


auto Mesh2::bnd_vertices() const -> es::util::Iterable<BoundaryVertexIter>
{
	return {begin_bnd_vertex(), end_bnd_vertex()};
}

// auto Mesh2::bnd_edges() const -> es::util::Iterable<Bnd_edge_iter, Bnd_edge_end_iter>
// {
// 	return {begin_bnd_edge(), end_bnd_edge()};
// }
}
}