#include <es/fe/mesh/view/view.hpp>
#include <es/fe/mesh.hpp>
#include <es/fe/mesh/iterator.hpp>
#include <es_util/function.hpp>
#include <ostream>
#include <cassert>

namespace fe
{
//////////////////////////////////////////////////////////////////////////
/** 1D mesh views */

// const geom::Point& View<Vertex_tag, Mesh1>::vertex() const
// {
// 	return mesh_.vertex(index_);
// }
// 
// View<Edge_tag, Mesh1> View<Vertex_tag, Mesh1>::_first_cell() const
// {
// 	const auto edge_index = (index_ == 0) ? 0 : index_ - 1;
// 	return View<Edge_tag, Mesh1>{mesh_, edge_index};
// }
// 
// Index View<Edge_tag, Mesh1>::vertex_index(Local_index index) const
// {
// 	assert(index < 2);
// 	return index_ + index;
// }
// 
// void View<Edge_tag, Mesh1>::vertex_indices(Index_array<2>& indices) const
// {
// 	indices[0] = vertex_index(0);
// 	indices[1] = vertex_index(1);
// }
// 
// const geom::Point& View<Edge_tag, Mesh1>::vertex(Local_index index) const
// {
// 	return mesh_.vertex(vertex_index(index));
// }


//////////////////////////////////////////////////////////////////////////
/* Face view */

#ifndef TRIANGULAR_CELLS_ONLY
Local_index View<Face_tag, Mesh2>::n_vertices() const
{
	Local_index number = 0;
	mesh_.halfedge_loop(bounding_halfedge(), [&number](Index) { ++number; return false; });
	return number;
}
#endif

Vertex_index View<Face_tag, Mesh2>::vertex_index(Local_index index) const
{
#ifdef TRIANGULAR_CELLS_ONLY			
	assert(index < 3);
#endif

	auto halfedge = bounding_halfedge();
	switch (index)
	{
	case 2:
		halfedge = mesh_.next(halfedge, Face_circ_tag{});
		[[fallthrough]];

	case 1:
		halfedge = mesh_.next(halfedge, Face_circ_tag{});

	#ifndef TRIANGULAR_CELLS_ONLY
		[[fallthrough]];

	case 0:
		break;

	default:
		for (Local_index i = 0; i < index; ++i)
			halfedge = mesh_.next(halfedge, Face_circ_tag{});
	#endif
	}

	return mesh_.halfedges_[*halfedge].vertex;
}

// std::ostream& operator<<(std::ostream& os, const View<Vertex_tag, Mesh1>& vertex)
// {
// 	os << "Vertex #" << *vertex << ": (" << vertex.vertex() << ')';
// 	return os;
// }

std::ostream& operator<<(std::ostream& os, const View<Vertex_tag, Mesh2>& vertex)
{
	os << "Vertex #" << **vertex << ": " << vertex.vertex();
	return os;
}

std::ostream& operator<<(std::ostream& os, const View<Edge_tag, Mesh2>& edge)
{
	// TODO
	throw;
// 	os << "Edge #" << **edge << ": "
// 		<< edge.vertex_from_index() << ' ' << edge.vertex_from() << " -> "
// 		<< edge.vertex_to_index() << ' ' << edge.vertex_to();

	return os;
}

std::ostream& operator<<(std::ostream& os, const View<Face_tag, Mesh2>& cell)
{
	// TODO
	throw;

	std::vector<Vertex_index> vertices;
	cell.vertex_indices(vertices);

	//os << "Cell #" << **cell << ": [" << es::util::join_as_string(vertices.begin(), vertices.end()) << "]\n";
// 	for (auto edge = cell.begin_edge(); edge != cell.end_edge(); ++edge)
// 		os << *edge << '\n';

	return os;
}
}


// 	Index View<Edge_tag, Mesh2>::oppositeVertexIndex(Local_index index) const
// 	{
// 		assert(index < 2);
// 
// 		const auto edge = (index == 0) ? index_ : mesh_.twin_halfedge_index(index_);
// 
// 		return mesh_.is_bnd_halfedge(edge) ?
// 			invalid_index : mesh_.halfedges_[mesh_.next_halfedge_index(edge)].vertex;
// 	}
