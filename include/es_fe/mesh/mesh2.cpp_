#include <es/fe/mesh.hpp>
#include <es/geom/geometry.hpp>
#include <es_util/function.hpp>
#include <set>
#include <fstream>
#include <string>
#include <algorithm>
#include <limits>
#include <ostream>

namespace fe
{
namespace
{
template<class Index>
std::string indexString(Index index)
{
	return is_valid(index) ? std::to_string(*index) : "<invalid index>";
}
}

//////////////////////////////////////////////////////////////////////////
/** Low level index-based element access */

Vertex_index Mesh2::vertex_index_by_halfedge(Halfedge_index index) const
{
	assert(index < n_halfedges());
	return halfedges_[*index].vertex;
}


bool Mesh2::is_first_halfedge(Halfedge_index index)
{
	return *index % 2 == 0;
}

bool Mesh2::is_second_halfedge(Halfedge_index index)
{
	return !is_first_halfedge(index);
}

Halfedge_index Mesh2::halfedge_index_by_vertex(Vertex_index index) const
{
	assert(index < n_vertices());
	return vertices_[*index].halfedge;
}

Face_index Mesh2::face_index_by_halfedge(Halfedge_index index) const
{
	assert(index < n_halfedges());
	return halfedges_[*index].face;
}

Face_index Mesh2::face_index_by_twin_halfedge(Halfedge_index index) const
{
	return face_index_by_halfedge(twin(index));
}

//////////////////////////////////////////////////////////////////////////
/** Flags */

bool Mesh2::is_empty() const
{
	return vertices_.empty() || halfedges_.empty() || faces_.empty();
}

//////////////////////////////////////////////////////////////////////////



geom::Rect Mesh2::bounding_box() const
{
	double x_min = std::numeric_limits<double>::max();
	double x_max = std::numeric_limits<double>::min();

	double y_min = std::numeric_limits<double>::max();
	double y_max = std::numeric_limits<double>::min();

	// TODO
	//for (auto vertex = begin_bnd_vertex(); vertex != end_bnd_vertex(); ++vertex)
	for (auto vertex = begin_vertex(); vertex != end_vertex(); ++vertex)
	{
		auto& v = vertex->vertex();
		x_min = std::min(x_min, v.x());
		x_max = std::max(x_max, v.x());
		y_min = std::min(y_min, v.y());
		y_max = std::max(y_max, v.y());
	}

	return {{x_min, y_min}, {x_max, y_max}};
}

//////////////////////////////////////////////////////////////////////////
/** Views */

auto Mesh2::view(Vertex_index index) const -> Vertex_view
{
	assert(index < n_vertices() || !is_valid(index));
	return Vertex_view{*this, index};
}

auto Mesh2::view(Edge_index index) const -> Edge_view
{
	assert(index < n_edges() || !is_valid(index));
	return Edge_view{*this, index};
}

auto Mesh2::view(Face_index index) const -> Face_view
{
	assert(index < n_faces() || !is_valid(index));
	return Face_view{*this, index};
}

//////////////////////////////////////////////////////////////////////////
/** Iterators */


auto Mesh2::begin_bnd_vertex() const -> BoundaryVertexIter
{
	return BoundaryVertexIter{*this, first_boundary_halfedge()};
}

auto Mesh2::end_bnd_vertex() const -> BoundaryVertexIter
{
	return BoundaryVertexIter{*this};
}

// auto Mesh2::begin_bnd_edge() const -> Bnd_edge_iter
// {
// 	return Bnd_edge_iter{*this, *first_boundary_halfedge()};
// }

auto Mesh2::end_bnd_edge() const -> Bnd_edge_end_iter
{
	return {};
}


auto Mesh2::bnd_vertices() const -> es::util::Iterable<BoundaryVertexIter>
{
	return {begin_bnd_vertex(), end_bnd_vertex()};
}

// auto Mesh2::bnd_edges() const -> es::util::Iterable<Bnd_edge_iter, Bnd_edge_end_iter>
// {
// 	return {begin_bnd_edge(), end_bnd_edge()};
// }
}
}